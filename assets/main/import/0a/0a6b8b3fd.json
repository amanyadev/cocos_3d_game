[1,["1brw/JvvpFnIvdrxpFCgMZ","20g1ukYUVPvKWKBRznAKo+@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","c6jIMHmfxEFqOkoPrUE0Ay@27a5c","80LinITIFMs5Z6VVG/Fk6t","7dj5uJT9FMn6OrOOx83tfK@f9941","1a/hWcLf5Bd7BdPvX0rkJW@43c35","1a/hWcLf5Bd7BdPvX0rkJW@ad24a","1a/hWcLf5Bd7BdPvX0rkJW@21957","1a/hWcLf5Bd7BdPvX0rkJW@1e79f","1a/hWcLf5Bd7BdPvX0rkJW@94bb3","1a/hWcLf5Bd7BdPvX0rkJW@66099","1a/hWcLf5Bd7BdPvX0rkJW@61608","1a/hWcLf5Bd7BdPvX0rkJW@e97a2","1a/hWcLf5Bd7BdPvX0rkJW@482eb","c6jIMHmfxEFqOkoPrUE0Ay@33df6","c6jIMHmfxEFqOkoPrUE0Ay@0602a","12Y9dMgWdJKJGmTiZyQR9H@a804a","1a7ZL+X4lNV63VHz0d/5k7","1a/hWcLf5Bd7BdPvX0rkJW@57eb5","1a/hWcLf5Bd7BdPvX0rkJW@29e0d","1a/hWcLf5Bd7BdPvX0rkJW@b037c","1a/hWcLf5Bd7BdPvX0rkJW@02359","c6jIMHmfxEFqOkoPrUE0Ay@58640","c6jIMHmfxEFqOkoPrUE0Ay@935df","c6jIMHmfxEFqOkoPrUE0Ay@40933","c6jIMHmfxEFqOkoPrUE0Ay@594f0","c6jIMHmfxEFqOkoPrUE0Ay@6c58f","c6jIMHmfxEFqOkoPrUE0Ay@96882","c6jIMHmfxEFqOkoPrUE0Ay@1ead6","12y1zp5xhB27WAWL8osyaz","1a/hWcLf5Bd7BdPvX0rkJW@8b7bb","1a/hWcLf5Bd7BdPvX0rkJW@6b9e5","1a/hWcLf5Bd7BdPvX0rkJW@1da29","1a/hWcLf5Bd7BdPvX0rkJW@6e70c","1a/hWcLf5Bd7BdPvX0rkJW@f3416","1a/hWcLf5Bd7BdPvX0rkJW@f8008","20g1ukYUVPvKWKBRznAKo+@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","d3x4IMKphEKYvHuEU7yaxB","12Y9dMgWdJKJGmTiZyQR9H@2e76e","c6jIMHmfxEFqOkoPrUE0Ay@5ccfe","c6jIMHmfxEFqOkoPrUE0Ay@949b9","c6jIMHmfxEFqOkoPrUE0Ay@4a4ef","c6jIMHmfxEFqOkoPrUE0Ay@f9d04","c6jIMHmfxEFqOkoPrUE0Ay@2d68c","c6jIMHmfxEFqOkoPrUE0Ay@396eb","c6jIMHmfxEFqOkoPrUE0Ay@6d208","c6jIMHmfxEFqOkoPrUE0Ay@3d42e","c6jIMHmfxEFqOkoPrUE0Ay@80c8f","c6jIMHmfxEFqOkoPrUE0Ay@86963","c6jIMHmfxEFqOkoPrUE0Ay@5008b","c6jIMHmfxEFqOkoPrUE0Ay@113b8","c6jIMHmfxEFqOkoPrUE0Ay@7338e","c6jIMHmfxEFqOkoPrUE0Ay@a7979","c6jIMHmfxEFqOkoPrUE0Ay@849d0","c6jIMHmfxEFqOkoPrUE0Ay@de4ea","c6jIMHmfxEFqOkoPrUE0Ay@cee67","c6jIMHmfxEFqOkoPrUE0Ay@cf9e4","c6jIMHmfxEFqOkoPrUE0Ay@db33f","c6jIMHmfxEFqOkoPrUE0Ay@3317c","c6jIMHmfxEFqOkoPrUE0Ay@179b3","c6jIMHmfxEFqOkoPrUE0Ay@abc04","c6jIMHmfxEFqOkoPrUE0Ay@6f2c6","c6jIMHmfxEFqOkoPrUE0Ay@e30db","c6jIMHmfxEFqOkoPrUE0Ay@958c2","c6jIMHmfxEFqOkoPrUE0Ay@92109","c6jIMHmfxEFqOkoPrUE0Ay@3dcfe","c6jIMHmfxEFqOkoPrUE0Ay@c74d3","c6jIMHmfxEFqOkoPrUE0Ay@5bedb","c6jIMHmfxEFqOkoPrUE0Ay@fb1c0","c6jIMHmfxEFqOkoPrUE0Ay@c1b8a","c6jIMHmfxEFqOkoPrUE0Ay@0c41c","c6jIMHmfxEFqOkoPrUE0Ay@29927","c6jIMHmfxEFqOkoPrUE0Ay@f8276","c6jIMHmfxEFqOkoPrUE0Ay@431da","c6jIMHmfxEFqOkoPrUE0Ay@a5058","c6jIMHmfxEFqOkoPrUE0Ay@b8a5e","c6jIMHmfxEFqOkoPrUE0Ay@99bd3","c6jIMHmfxEFqOkoPrUE0Ay@44201","c6jIMHmfxEFqOkoPrUE0Ay@1834a","c6jIMHmfxEFqOkoPrUE0Ay@e4be3","c6jIMHmfxEFqOkoPrUE0Ay@def63","c6jIMHmfxEFqOkoPrUE0Ay@8d690","c6jIMHmfxEFqOkoPrUE0Ay@44766","c6jIMHmfxEFqOkoPrUE0Ay@88663","c6jIMHmfxEFqOkoPrUE0Ay@46178","c6jIMHmfxEFqOkoPrUE0Ay@4f3a8","c6jIMHmfxEFqOkoPrUE0Ay@bf407","c6jIMHmfxEFqOkoPrUE0Ay@d12f5","c6jIMHmfxEFqOkoPrUE0Ay@82e07","c6jIMHmfxEFqOkoPrUE0Ay@57b76","c6jIMHmfxEFqOkoPrUE0Ay@28f62","c6jIMHmfxEFqOkoPrUE0Ay@30697","c6jIMHmfxEFqOkoPrUE0Ay@d272d","c6jIMHmfxEFqOkoPrUE0Ay@cdb96","c6jIMHmfxEFqOkoPrUE0Ay@1c331","c6jIMHmfxEFqOkoPrUE0Ay@d0490","c6jIMHmfxEFqOkoPrUE0Ay@b0c4c","c6jIMHmfxEFqOkoPrUE0Ay@9e176","c6jIMHmfxEFqOkoPrUE0Ay@5b3cc","c6jIMHmfxEFqOkoPrUE0Ay@6e880","c6jIMHmfxEFqOkoPrUE0Ay@5054b","c6jIMHmfxEFqOkoPrUE0Ay@63b4a","c6jIMHmfxEFqOkoPrUE0Ay@9ab4e","c6jIMHmfxEFqOkoPrUE0Ay@8ad66","c6jIMHmfxEFqOkoPrUE0Ay@4fa0f","c6jIMHmfxEFqOkoPrUE0Ay@813f7","c6jIMHmfxEFqOkoPrUE0Ay@4e7b3","c6jIMHmfxEFqOkoPrUE0Ay@104a0","c6jIMHmfxEFqOkoPrUE0Ay@e4a47","c6jIMHmfxEFqOkoPrUE0Ay@e486f","c6jIMHmfxEFqOkoPrUE0Ay@d95cb","c6jIMHmfxEFqOkoPrUE0Ay@8e99a","c6jIMHmfxEFqOkoPrUE0Ay@09c86","c6jIMHmfxEFqOkoPrUE0Ay@dff3d","c6jIMHmfxEFqOkoPrUE0Ay@024cf","c6jIMHmfxEFqOkoPrUE0Ay@73fd1","c6jIMHmfxEFqOkoPrUE0Ay@284a4","c6jIMHmfxEFqOkoPrUE0Ay@23c09","c6jIMHmfxEFqOkoPrUE0Ay@34c07","c6jIMHmfxEFqOkoPrUE0Ay@4e1f8","c6jIMHmfxEFqOkoPrUE0Ay@b0cb0","c6jIMHmfxEFqOkoPrUE0Ay@aa0d1","c6jIMHmfxEFqOkoPrUE0Ay@8097c","c6jIMHmfxEFqOkoPrUE0Ay@0cd76","ba/lSsEVlE8LjxCdeS/KgY","54ouuZ6f9HfaR5lJVvKhoz","7dj5uJT9FMn6OrOOx83tfK@6c48a","95EkngnxZFbYuFpsqVTaFr@6c48a","c6jIMHmfxEFqOkoPrUE0Ay@18d32"],["node","_effectAsset","_mesh","_spriteFrame","_target","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite","_parent","mainTexture","_textureSource","final","scoreLabel","camera","_cameraComponent","scene"],[["cc.Node",["_name","_layer","_id","_objFlags","_active","_parent","_components","_lpos","_lscale","_lrot","_euler","_children"],-2,1,9,5,5,5,5,12],["cc.Node",["_name","_id","_layer","_active","_children","_lpos","_parent","_components","_lscale","_lrot","_euler"],-1,2,5,1,9,5,5,5],["cc.Label",["_string","_actualFontSize","_fontSize","_horizontalAlign","_overflow","_lineHeight","_enableWrapText","node"],-4,1],"cc.SpriteFrame",["cc.Material",["_defines","_states","_name","_props"],0,12],["cc.UITransform",["node","_contentSize"],3,1,5],["cc.Sprite",["_sizeMode","_type","node","_color","_spriteFrame"],1,1,5,6],["cc.MeshRenderer",["_name","node","_materials","lightmapSettings","_mesh"],2,1,3,4,6],["cc.Camera",["_visibility","_projection","_priority","_orthoHeight","_far","_clearFlags","_iso","node","_color"],-4,1,5],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Material",["_name","_props","_states","_defines"],-1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.SceneAsset",["_name"],2],["cc.Node",["_name","_layer","_parent","_components","_lpos"],1,1,12,5],["cc.Node",["_name","_parent","_components","_lpos"],2,1,2,5],["959d1lGHYZJGIN+X82CMXkA",["node","camera","scoreLabel","Questions","final"],3,1,1,1,2,1],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.Widget",["_alignFlags","node"],2,1],["480feVDe8dDrp6fBZv8GfhW",["node"],3,1],["cc.Scene",["_name","_children","_globals"],2,2,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog"],3,4,4,4,4],["cc.AmbientInfo",[],3],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",[],3],["cc.Button",["_transition","_zoomScale","node","clickEvents","_normalColor","_target","_normalSprite","_hoverSprite","_pressedSprite","_disabledSprite"],1,1,9,5,1,6,6,6,6],["cc.ClickEvent",["_componentId","handler","customEventData","target"],0,1],["c11ebUug0FJ6a/LEtcJhFKJ",["node"],3,1],["cc.DirectionalLight",["node","_staticSettings"],3,1,4],["cc.StaticLightSettings",[],3],["e1a6dRMCGVK2Lw3KvMoW8Az",["minDistance","node","NPCNode","hintNode","interactionUI","interactPrompt"],2,1,1,1,1,1],["cc.MeshRenderer",["_materials","node","lightmapSettings","_mesh"],2,1,4,6],["cc.ModelLightmapSettings",[],3]],[[4,2,1,0,3,4],[32,1],[5,0,1,1],[7,1,2,3,4,1],[9,0,1,2,3],[0,0,5,6,7,9,8,10,2],[0,0,5,6,2],[1,0,2,6,4,7,5,3],[6,1,0,2,3,4,3],[25,0,1,2,3,4,5,6,7,8,9,3],[26,0,1,2,3,4],[2,0,1,2,4,6,7,6],[0,0,3,1,5,6,4],[0,0,1,5,6,7,3],[31,0,1,2,3,2],[4,1,0,3,3],[6,0,2,3,4,2],[18,0,1],[2,0,3,1,2,7,5],[7,0,1,2,3,4,2],[0,0,5,6,9,8,10,2],[1,0,4,7,5,9,8,10,2],[1,0,3,4,5,3],[1,0,6,4,2],[1,0,6,4,7,5,8,2],[27,0,1],[2,0,3,1,2,4,7,6],[10,0,1,2,3,5],[0,0,3,1,5,6,7,4],[2,0,1,2,7,4],[4,0,2],[11,0,1,2,4],[12,0,2],[0,0,11,7,8,2],[0,0,5,2],[0,0,2,6,3],[0,0,4,1,5,6,4],[0,0,2,5,6,9,10,3],[0,0,5,6,8,2],[1,0,2,1,4,7,5,4],[1,0,4,7,5,8,2],[1,0,1,4,3],[1,0,6,4,7,2],[1,0,6,4,5,2],[1,0,3,6,4,5,3],[1,0,1,6,4,5,9,10,3],[13,0,1,2,3,4,3],[14,0,1,2,3,2],[15,0,1,2,3,4,1],[5,0,1],[16,0,1,1],[17,0,1,2],[19,0,1,2,2],[20,0,1,2,3,1],[21,1],[22,0,1],[23,1],[24,1],[2,0,3,1,2,5,7,6],[28,0,1,1],[29,1],[30,0,1,2,3,4,5,2],[8,1,2,3,4,5,0,7,8,7],[8,6,0,7,3]],[[[[4,".bin",2714577712,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":1200,"count":600,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[4,".bin",4094896171,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":72,"count":36,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{},{},{},{}],[[[{},"mainColor",8,[4,4278386464]],{},{},{}],11,0,0,0]]],0,0,[0],[1],[0]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{},{},{},{}],[[[{},"mainColor",8,[4,4294905435]],{},{},{}],11,0,0,0]]],0,0,[0],[1],[0]],[[[0,"7",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.42277371883392334},"mainTexture",6,0]],11]]],0,0,[0,0],[10,1],[32,0]],[[[4,".bin",3283341965,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":15840,"length":4368,"count":1092,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":15840,"count":330,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0007619999814778566,-0.00020700000459328294,0.005229000002145767],"maxPosition",8,[1,0.0008820000221021473,0.0011840000515803695,0.007012000307440758]]],-1],0,0,[],[],[]],[[[0,"3",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.42277371883392334},"mainTexture",6,0]],11]]],0,0,[0,0],[10,1],[33,0]],[[[0,"2",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.42277371883392334},"mainTexture",6,0]],11]]],0,0,[0,0],[10,1],[34,0]],[[[4,".bin",2824040079,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":53040,"length":18984,"count":4746,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":53040,"count":1105,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002495999913662672,-0.0019600000232458115,-0.010139000602066517],"maxPosition",8,[1,0.0023060000967234373,0.0019329999340698123,0.0016349999932572246]]],-1],0,0,[],[],[]],[[[4,".bin",1008351167,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":108672,"length":39372,"count":9843,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":108672,"count":2264,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0059369998052716255,-0.001424000016413629,-0.0016550000291317701],"maxPosition",8,[1,0.00585100008174777,0.0028780000284314156,0.00606500031426549]]],-1],0,0,[],[],[]],[[[0,"1",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.42277371883392334},"mainTexture",6,0]],11]]],0,0,[0,0],[10,1],[35,0]],[[[4,".bin",833053526,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3936,"length":1728,"count":432,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3936,"count":82,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0005879999953322113,-0.0006409999914467335,0.006767000071704388],"maxPosition",8,[1,0.0004259999841451645,-0.0004459999909158796,0.007110999897122383]]],-1],0,0,[],[],[]],[[[0,"5",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.42277371883392334},"mainTexture",6,0]],11]]],0,0,[0,0],[10,1],[36,0]],[[[4,".bin",854899950,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":77952,"length":18936,"count":4734,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":77952,"count":1624,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0027729999274015427,-0.002202000003308058,-0.00380899989977479],"maxPosition",8,[1,0.0031190000008791685,0.0031369999051094055,0.0070329997688531876]]],-1],0,0,[],[],[]],[[[4,".bin",662153730,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":10800,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":10800,"count":225,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0005160000291652977,-0.0008319999906234443,0.007179999724030495],"maxPosition",8,[1,0.00038899999344721437,0.0014830001164227724,0.008425000123679638]]],-1],0,0,[],[],[]],[[[0,"4",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.42277371883392334},"mainTexture",6,0]],11]]],0,0,[0,0],[10,1],[37,0]],[[[4,".bin",356607833,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":44688,"length":19716,"count":4929,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":44688,"count":931,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0010320000583305955,-0.0010509999701753259,0.00445899972692132],"maxPosition",8,[1,0.0009190000128000975,0.0014219998847693205,0.008317000232636929]]],-1],0,0,[],[],[]],[[[31,"builtin-standard",[{"hash":3247695832,"name":"builtin-standard|standard-vs|standard-fs","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(location = 0) in float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * miscParams.x) * normalize(v_tangent) +\n      (nmmp.y * miscParams.x) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.w;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * miscParams.x) * normalize(v_tangent) +\n      (nmmp.y * miscParams.x) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.w;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  layout(location = 3) out vec4 fragColor3;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(s.position, s.roughness);\n    fragColor2 = vec4(s.normal, s.metallic);\n    fragColor3 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 miscParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nvarying float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse) * s.occlusion;\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * miscParams.x) * normalize(v_tangent) +\n      (nmmp.y * miscParams.x) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.w;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, s.position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, s.position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, s.position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(s.position, s.roughness);\n    gl_FragData[2] = vec4(s.normal, s.metallic);\n    gl_FragData[3] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":220,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":63}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","type":16,"count":1,"stageFlags":1,"format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":1,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":1,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":1,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}]},{"hash":1783225275,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":183,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":63}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","type":14,"count":1,"stageFlags":1,"format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":1,"location":3,"defines":[]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}},"migrations":{"properties":{"pbrParams":{"removeImmediately":true}}}},{"phase":"deferred","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","blendState":{"targets":[{"blend":false},{"blend":false},{"blend":false},{"blend":false}]},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["miscParams",0,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"miscParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0,0,0]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["pbrParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,1]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[3],0,[0],[11],[38]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[3],0,[0],[11],[39]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{},{},{},{}],[[[{},"mainColor",8,[4,4278190080]],{},{},{}],11,0,0,0]]],0,0,[0],[1],[0]],[[[32,"scene"],[33,"Model",[[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,[34,"hillvalley55_share",-22]],1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4],[1,0,0.001,0],[1,100,100,100]],[35,"Controller","55WvTnlVJA57OlRtYyAXRv",[[48,-31,-30,-29,[-24,-25,-26,-27,-28],-23]]],[39,"Canvas",33554432,"adih7jVFdJPL4AClE3+ne5",[-36,-37,-38,-39,-40,-41,-42],[[2,-32,[5,960,640]],[50,-34,-33],[51,45,-35]],[1,480,320,0]],[40,"soap",[-44,-45,-46,-47,-48,-49,-50],[[17,-43]],[1,0,0,-8.379],[1,1.373,1.373,1.373]],[21,"soap-001",[-52,-53,-54,-55,-56,-57,-58],[[17,-51]],[1,3.392,0,-6.412],[3,0,-0.9495487089811834,0,0.3136195932529852],[1,1.373,1.373,1.373],[1,0,-143.445,0]],[21,"soap-002",[-60,-61,-62,-63,-64,-65,-66],[[17,-59]],[1,5.308,0,-8.998],[3,0,-0.9495487089811834,0,0.3136195932529852],[1,1.373,1.373,1.373],[1,0,-143.445,0]],[21,"soap-003",[-68,-69,-70,-71,-72,-73,-74],[[17,-67]],[1,3.067,0,2.599],[3,0,-0.6791146839314158,0,0.7340321832649663],[1,1.373,1.373,1.373],[1,0,-85.549,0]],[22,"Question MCQ",false,[-75,-76,-77,-78,-79,-80],[1,-480,-320,0]],[22,"Question MCQ-001",false,[-81,-82,-83,-84,-85,-86],[1,-480,-320,0]],[22,"Question MCQ-002",false,[-87,-88,-89,-90,-91,-92],[1,-480,-320,0]],[41,"Models","1a4bZ7N31JvbkNPuCZ3le0",[-93,-94,1,-95,-96,-97]],[42,"Questions",3,[8,9,-99,-100,10],[[49,-98]]],[52,"scene",[-101,2,-102,11,3],[53,[54],[55,[4,4283190348]],[56],[57]]],[23,"NPCNode",11,[4,5,6,7]],[7,"Choice 1",33554432,9,[-107],[[2,-103,[5,368.23799999999994,32.635391715838054]],[8,1,0,-104,[4,4282868735],177],[9,3,0.8,-106,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-105,178,179,180,181]],[1,489.1185,342.27130414208096,0]],[7,"Choice 2",33554432,9,[-112],[[2,-108,[5,368.23799999999994,32.635391715838054]],[8,1,0,-109,[4,4294018892],182],[9,3,0.8,-111,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-110,183,184,185,186]],[1,489.1185,297.2874960857627,0]],[7,"Choice 3",33554432,9,[-117],[[2,-113,[5,368.23799999999994,32.635391715838054]],[8,1,0,-114,[4,4284350225],187],[9,3,0.8,-116,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","10",2]],[4,4292269782],-115,188,189,190,191]],[1,489.1185,252.3045039142373,0]],[7,"Choice 4",33554432,9,[-122],[[2,-118,[5,368.23799999999994,32.635391715838054]],[8,1,0,-119,[4,4284572001],192],[9,3,0.8,-121,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-120,193,194,195,196]],[1,489.1185,207.32069585791902,0]],[43,"Question YN",12,[-123,-124,-125,-126],[1,-480,-320,0]],[7,"Yes-001",33554432,19,[-131],[[2,-127,[5,150,40]],[8,1,0,-128,[4,4278222848],198],[9,3,0.8,-130,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","20",2]],[4,4292269782],-129,199,200,201,202]],[1,380,214.536,0]],[7,"No-001",33554432,19,[-136],[[2,-132,[5,150,40]],[8,1,0,-133,[4,4282868735],203],[9,3,0.8,-135,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","20",2]],[4,4292269782],-134,204,205,206,207]],[1,580,214.536,0]],[44,"Question YN-001",false,12,[-137,-138,-139,-140],[1,-480,-320,0]],[7,"Yes-001",33554432,22,[-145],[[2,-141,[5,150,40]],[8,1,0,-142,[4,4282868735],209],[9,3,0.8,-144,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","20",2]],[4,4292269782],-143,210,211,212,213]],[1,380,214.536,0]],[7,"No-001",33554432,22,[-150],[[2,-146,[5,150,40]],[8,1,0,-147,[4,4282868735],214],[9,3,0.8,-149,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","20",2]],[4,4292269782],-148,215,216,217,218]],[1,580,214.536,0]],[7,"Choice 1",33554432,10,[-155],[[2,-151,[5,368.23799999999994,32.635391715838054]],[8,1,0,-152,[4,4294018892],220],[9,3,0.8,-154,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-153,221,222,223,224]],[1,489.1185,342.27130414208096,0]],[7,"Choice 2",33554432,10,[-160],[[2,-156,[5,368.23799999999994,32.635391715838054]],[8,1,0,-157,[4,4294018892],225],[9,3,0.8,-159,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-158,226,227,228,229]],[1,489.1185,297.2874960857627,0]],[7,"Choice 3",33554432,10,[-165],[[2,-161,[5,368.23799999999994,32.635391715838054]],[8,1,0,-162,[4,4294018892],230],[9,3,0.8,-164,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","10",2]],[4,4292269782],-163,231,232,233,234]],[1,489.1185,252.3045039142373,0]],[7,"Choice 4",33554432,10,[-170],[[2,-166,[5,368.23799999999994,32.635391715838054]],[8,1,0,-167,[4,4294018892],235],[9,3,0.8,-169,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-168,236,237,238,239]],[1,489.1185,207.32069585791902,0]],[7,"Choice 1",33554432,8,[-175],[[2,-171,[5,368.23799999999994,32.635391715838054]],[8,1,0,-172,[4,4294018892],241],[9,3,0.8,-174,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-173,242,243,244,245]],[1,489.1185,342.27130414208096,0]],[7,"Choice 2",33554432,8,[-180],[[2,-176,[5,368.23799999999994,32.635391715838054]],[8,1,0,-177,[4,4294018892],246],[9,3,0.8,-179,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-178,247,248,249,250]],[1,489.1185,297.2874960857627,0]],[7,"Choice 3",33554432,8,[-185],[[2,-181,[5,368.23799999999994,32.635391715838054]],[8,1,0,-182,[4,4294018892],251],[9,3,0.8,-184,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","10",2]],[4,4292269782],-183,252,253,254,255]],[1,489.1185,252.3045039142373,0]],[7,"Choice 4",33554432,8,[-190],[[2,-186,[5,368.23799999999994,32.635391715838054]],[8,1,0,-187,[4,4294018892],256],[9,3,0.8,-189,[[10,"959d1lGHYZJGIN+X82CMXkA","addScore","0",2]],[4,4292269782],-188,257,258,259,260]],[1,489.1185,207.32069585791902,0]],[45,"Main Camera","1d+hquN6tAS4E/QN+xFoEY",13,[-191,-192],[1,-4.673,0.801,-6.521],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,0,-90,0]],[23,"Group1",1,[-193,-194,-195]],[24,"Hint",11,[-197],[[25,-196]],[1,-1.611,0.727,-5.261],[1,0.67,0.67,0.67]],[13,"points-001",33554432,3,[[2,-198,[5,164.51,50.4]],[18,"Press E to Interact",0,20,20,-199]],[1,362.088,-260.572,0]],[36,"Final",false,33554432,3,[[2,-200,[5,287.18,50.4]],[58,"Your score is",0,50,50,50,-201]]],[24,"Hint-001",11,[-203],[[25,-202]],[1,0.486,0.727,-5.261],[1,0.67,0.67,0.67]],[24,"Hint-002",11,[-205],[[25,-204]],[1,0.486,0.727,-7.59],[1,0.67,0.67,0.67]],[13,"q_texts",33554432,3,[[2,-206,[5,128.91,50.4]],[18,"QUESTIONS :",0,20,20,-207]],[1,-372.695,265.028,0]],[46,"points",33554432,3,[[[2,-208,[5,71.12,50.4]],-209],4,1],[1,362.088,265.028,0]],[13,"points-002",33554432,3,[[2,-210,[5,153.37,50.4]],[18,"W S A D to move",0,20,20,-211]],[1,-354.639,-260.572,0]],[13,"SpriteSplash-001",33554432,9,[[2,-212,[5,588.991,315.497]],[16,0,-213,[4,1140850688],176]],[1,480,320,0]],[13,"Label-001",33554432,9,[[2,-214,[5,543.54,50.4]],[26,"MBA karni hai? Engineering hogyi kya?",0,20,20,3,-215]],[1,480.657,414.602,0]],[12,"Label",512,33554432,15,[[2,-216,[5,297.818,40]],[11,"IIT NAHI MILA",20,20,1,false,-217]]],[12,"Label",512,33554432,16,[[2,-218,[5,297.818,40]],[11,"Commerce Vale hain",20,20,1,false,-219]]],[12,"Label",512,33554432,17,[[2,-220,[5,297.818,40]],[11,"invact hai naaa!",20,20,1,false,-221]]],[12,"Label",512,33554432,18,[[2,-222,[5,297.818,40]],[11,"2 States dekh li thi",20,20,1,false,-223]]],[13,"SpriteSplash-001",33554432,19,[[2,-224,[5,588.991,315.497]],[16,0,-225,[4,1140850688],197]],[1,480,320,0]],[13,"Label-001",33554432,19,[[2,-226,[5,242.34,50.4]],[29,"Do you like the Metaverse?",20,20,-227]],[1,480,329.2835,0]],[12,"Label",512,33554432,20,[[2,-228,[5,100,40]],[11,"Yes",20,20,1,false,-229]]],[28,"Label",512,33554432,21,[[2,-230,[5,151.125,40]],[11,"Obviously Yes!",20,20,1,false,-231]],[1,-0.6555,0,0]],[13,"SpriteSplash-001",33554432,22,[[2,-232,[5,588.991,315.497]],[16,0,-233,[4,1140850688],208]],[1,480,320,0]],[13,"Label-001",33554432,22,[[2,-234,[5,167.84,50.4]],[29,"Do you like AI / ML",20,20,-235]],[1,480,329.2835,0]],[12,"Label",512,33554432,23,[[2,-236,[5,100,40]],[11,"No",20,20,1,false,-237]]],[28,"Label",512,33554432,24,[[2,-238,[5,151.125,40]],[11,"Obviously No",20,20,1,false,-239]],[1,-0.6555,0,0]],[13,"SpriteSplash-001",33554432,10,[[2,-240,[5,588.991,315.497]],[16,0,-241,[4,1140850688],219]],[1,480,320,0]],[13,"Label-001",33554432,10,[[2,-242,[5,543.54,90.39999999999999]],[26,"\"______________ are social inventions for accomplishing goals through group efforts\"",0,20,20,3,-243]],[1,480.657,414.602,0]],[12,"Label",512,33554432,25,[[2,-244,[5,297.818,40]],[11,"Management",20,20,1,false,-245]]],[12,"Label",512,33554432,26,[[2,-246,[5,297.818,40]],[11,"Organisation",20,20,1,false,-247]]],[12,"Label",512,33554432,27,[[2,-248,[5,297.818,40]],[11,"Leadership",20,20,1,false,-249]]],[12,"Label",512,33554432,28,[[2,-250,[5,297.818,40]],[11,"Behavior",20,20,1,false,-251]]],[13,"SpriteSplash-001",33554432,8,[[2,-252,[5,588.991,315.497]],[16,0,-253,[4,1140850688],240]],[1,480,320,0]],[13,"Label-001",33554432,8,[[2,-254,[5,543.54,90.39999999999999]],[26,"Management information system usually NOT serves managers interested in _______ results.",0,20,20,3,-255]],[1,480.657,414.602,0]],[12,"Label",512,33554432,29,[[2,-256,[5,297.818,40]],[11,"Weekly",20,20,1,false,-257]]],[12,"Label",512,33554432,30,[[2,-258,[5,297.818,40]],[11,"Monthly",20,20,1,false,-259]]],[12,"Label",512,33554432,31,[[2,-260,[5,297.818,40]],[11,"Yearly",20,20,1,false,-261]]],[12,"Label",512,33554432,32,[[2,-262,[5,297.818,40]],[11,"Day to Day",20,20,1,false,-263]]],[37,"Main Light","c0y6F5f+pAvI805TdmxIjx",13,[[59,-264,[60]]],[3,-0.24999999999999997,-0.24999999999999997,-0.06698729810778066,0.9330127018922194],[1,-30,-30,0]],[23,"Node",33,[-265]],[6,"player",70,[[61,5,-266,14,35,8,36]]],[38,"Plane",11,[[19,"Plane<ModelComponent>",-267,[0],[1],1]],[1,10,1,10]],[6,"Mesh1",34,[[3,-268,[2,3,4,5],[1],6]]],[6,"Mesh2",34,[[3,-269,[7,8],[1],9]]],[6,"Mesh3",34,[[14,[null],-270,[1],10]]],[6,"Mesh4",1,[[3,-271,[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80],[1],81]]],[6,"Mesh5",1,[[14,[null],-272,[1],82]]],[6,"Mesh6",1,[[14,[null],-273,[1],83]]],[6,"Mesh7",1,[[14,[null],-274,[1],84]]],[6,"Mesh8",1,[[3,-275,[85],[1],86]]],[6,"Mesh9",1,[[14,[null],-276,[1],87]]],[6,"Mesh10",1,[[3,-277,[88,89],[1],90]]],[6,"Mesh11",1,[[3,-278,[91,92],[1],93]]],[6,"Mesh12",1,[[14,[null],-279,[1],94]]],[6,"Mesh13",1,[[3,-280,[95],[1],96]]],[6,"Mesh14",1,[[3,-281,[97],[1],98]]],[6,"Mesh15",1,[[3,-282,[99],[1],100]]],[6,"Mesh16",1,[[3,-283,[101,102],[1],103]]],[6,"Mesh17",1,[[3,-284,[104],[1],105]]],[6,"Mesh18",1,[[3,-285,[106],[1],107]]],[6,"Mesh19",1,[[14,[null],-286,[1],108]]],[6,"Mesh20",1,[[14,[null],-287,[1],109]]],[6,"Mesh21",1,[[14,[null],-288,[1],110]]],[6,"Mesh22",1,[[14,[null],-289,[1],111]]],[6,"Mesh23",1,[[14,[null],-290,[1],112]]],[20,"cube",35,[[19,"Cube<ModelComponent>",-291,[113],[1],114]],[3,0.2751624902403262,-0.08589811207211051,0.4060319253775089,0.867205393134419],[1,0.258,0.258,0.258],[1,46.513,-29.603,41.068]],[20,"cube",38,[[19,"Cube<ModelComponent>",-292,[115],[1],116]],[3,0.2751624902403262,-0.08589811207211051,0.4060319253775089,0.867205393134419],[1,0.258,0.258,0.258],[1,46.513,-29.603,41.068]],[20,"cube",39,[[19,"Cube<ModelComponent>",-293,[117],[1],118]],[3,0.2751624902403262,-0.08589811207211051,0.4060319253775089,0.867205393134419],[1,0.258,0.258,0.258],[1,46.513,-29.603,41.068]],[5,"lower",4,[[3,-294,[119],[1],120]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"hair",4,[[3,-295,[121],[1],122]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"feet",4,[[3,-296,[123],[1],124]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"accs",4,[[3,-297,[125],[1],126]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"eye",4,[[3,-298,[127],[1],128]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"head",4,[[3,-299,[129],[1],130]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"upper",4,[[3,-300,[131],[1],132]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"lower",5,[[3,-301,[133],[1],134]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"hair",5,[[3,-302,[135],[1],136]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"feet",5,[[3,-303,[137],[1],138]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"accs",5,[[3,-304,[139],[1],140]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"eye",5,[[3,-305,[141],[1],142]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"head",5,[[3,-306,[143],[1],144]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"upper",5,[[3,-307,[145],[1],146]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"lower",6,[[3,-308,[147],[1],148]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"hair",6,[[3,-309,[149],[1],150]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"feet",6,[[3,-310,[151],[1],152]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"accs",6,[[3,-311,[153],[1],154]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"eye",6,[[3,-312,[155],[1],156]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"head",6,[[3,-313,[157],[1],158]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"upper",6,[[3,-314,[159],[1],160]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"lower",7,[[3,-315,[161],[1],162]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"hair",7,[[3,-316,[163],[1],164]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"feet",7,[[3,-317,[165],[1],166]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"accs",7,[[3,-318,[167],[1],168]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"eye",7,[[3,-319,[169],[1],170]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"head",7,[[3,-320,[171,172],[1],173]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[5,"upper",7,[[3,-321,[174],[1],175]],[1,0.0006964284111745656,0.4762535095214844,0.010755214840173721],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,46.99053192138672,46.99053192138672,46.99053192138672],[1,-90.00000000000003,0,0]],[47,"Camera",3,[-322],[1,0,0,1000]],[62,0,1073741824,320,2000,6,41943040,127,[4,4278190080]],[18,"SCORE",0,20,20,41],[6,"Camera",33,[[63,1,1083179008,-323]]]],0,[0,-1,34,0,-2,76,0,-3,77,0,-4,78,0,-5,79,0,-6,80,0,-7,81,0,-8,82,0,-9,83,0,-10,84,0,-11,85,0,-12,86,0,-13,87,0,-14,88,0,-15,89,0,-16,90,0,-17,91,0,-18,92,0,-19,93,0,-20,94,0,-21,95,0,9,1,0,12,37,0,-1,19,0,-2,8,0,-3,9,0,-4,10,0,-5,22,0,13,129,0,14,33,0,0,2,0,0,3,0,15,128,0,0,3,0,0,3,0,-1,127,0,-2,12,0,-3,40,0,-4,41,0,-5,36,0,-6,42,0,-7,37,0,0,4,0,-1,99,0,-2,100,0,-3,101,0,-4,102,0,-5,103,0,-6,104,0,-7,105,0,0,5,0,-1,106,0,-2,107,0,-3,108,0,-4,109,0,-5,110,0,-6,111,0,-7,112,0,0,6,0,-1,113,0,-2,114,0,-3,115,0,-4,116,0,-5,117,0,-6,118,0,-7,119,0,0,7,0,-1,120,0,-2,121,0,-3,122,0,-4,123,0,-5,124,0,-6,125,0,-7,126,0,-1,63,0,-2,64,0,-3,29,0,-4,30,0,-5,31,0,-6,32,0,-1,43,0,-2,44,0,-3,15,0,-4,16,0,-5,17,0,-6,18,0,-1,57,0,-2,58,0,-3,25,0,-4,26,0,-5,27,0,-6,28,0,-1,14,0,-2,72,0,-4,35,0,-5,38,0,-6,39,0,0,12,0,-3,19,0,-4,22,0,-1,69,0,-3,33,0,0,15,0,0,15,0,4,15,0,0,15,0,-1,45,0,0,16,0,0,16,0,4,16,0,0,16,0,-1,46,0,0,17,0,0,17,0,4,17,0,0,17,0,-1,47,0,0,18,0,0,18,0,4,18,0,0,18,0,-1,48,0,-1,49,0,-2,50,0,-3,20,0,-4,21,0,0,20,0,0,20,0,4,20,0,0,20,0,-1,51,0,0,21,0,0,21,0,4,21,0,0,21,0,-1,52,0,-1,53,0,-2,54,0,-3,23,0,-4,24,0,0,23,0,0,23,0,4,23,0,0,23,0,-1,55,0,0,24,0,0,24,0,4,24,0,0,24,0,-1,56,0,0,25,0,0,25,0,4,25,0,0,25,0,-1,59,0,0,26,0,0,26,0,4,26,0,0,26,0,-1,60,0,0,27,0,0,27,0,4,27,0,0,27,0,-1,61,0,0,28,0,0,28,0,4,28,0,0,28,0,-1,62,0,0,29,0,0,29,0,4,29,0,0,29,0,-1,65,0,0,30,0,0,30,0,4,30,0,0,30,0,-1,66,0,0,31,0,0,31,0,4,31,0,0,31,0,-1,67,0,0,32,0,0,32,0,4,32,0,0,32,0,-1,68,0,-1,70,0,-2,130,0,-1,73,0,-2,74,0,-3,75,0,0,35,0,-1,96,0,0,36,0,0,36,0,0,37,0,0,37,0,0,38,0,-1,97,0,0,39,0,-1,98,0,0,40,0,0,40,0,0,41,0,-2,129,0,0,42,0,0,42,0,0,43,0,0,43,0,0,44,0,0,44,0,0,45,0,0,45,0,0,46,0,0,46,0,0,47,0,0,47,0,0,48,0,0,48,0,0,49,0,0,49,0,0,50,0,0,50,0,0,51,0,0,51,0,0,52,0,0,52,0,0,53,0,0,53,0,0,54,0,0,54,0,0,55,0,0,55,0,0,56,0,0,56,0,0,57,0,0,57,0,0,58,0,0,58,0,0,59,0,0,59,0,0,60,0,0,60,0,0,61,0,0,61,0,0,62,0,0,62,0,0,63,0,0,63,0,0,64,0,0,64,0,0,65,0,0,65,0,0,66,0,0,66,0,0,67,0,0,67,0,0,68,0,0,68,0,0,69,0,-1,71,0,0,71,0,0,72,0,0,73,0,0,74,0,0,75,0,0,76,0,0,77,0,0,78,0,0,79,0,0,80,0,0,81,0,0,82,0,0,83,0,0,84,0,0,85,0,0,86,0,0,87,0,0,88,0,0,89,0,0,90,0,0,91,0,0,92,0,0,93,0,0,94,0,0,95,0,0,96,0,0,97,0,0,98,0,0,99,0,0,100,0,0,101,0,0,102,0,0,103,0,0,104,0,0,105,0,0,106,0,0,107,0,0,108,0,0,109,0,0,110,0,0,111,0,0,112,0,0,113,0,0,114,0,0,115,0,0,116,0,0,117,0,0,118,0,0,119,0,0,120,0,0,121,0,0,122,0,0,123,0,0,124,0,0,125,0,0,126,0,-1,128,0,0,130,0,16,13,1,9,11,2,9,13,3,9,13,4,9,14,5,9,14,6,9,14,7,9,14,8,9,12,9,9,12,10,9,12,11,9,13,323],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,-1,-2,-3,-4,2,-1,-2,2,2,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,2,2,2,2,-1,2,2,-1,-2,2,-1,-2,2,2,-1,2,-1,2,-1,2,-1,-2,2,-1,2,-1,2,2,2,2,2,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,-2,2,-1,2,3,3,5,6,7,8,3,5,6,7,8,3,5,6,7,8,3,5,6,7,8,3,3,5,6,7,8,3,5,6,7,8,3,3,5,6,7,8,3,5,6,7,8,3,3,5,6,7,8,3,5,6,7,8,3,5,6,7,8,3,5,6,7,8,3,3,5,6,7,8,3,5,6,7,8,3,5,6,7,8,3,5,6,7,8],[40,41,16,17,42,43,44,16,24,45,46,47,48,17,25,49,50,51,52,53,54,55,56,57,4,26,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,27,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,28,98,99,100,16,24,101,102,103,104,105,106,29,30,107,108,109,110,26,111,112,28,30,113,25,17,114,115,27,116,4,117,4,118,4,29,119,4,120,4,121,122,123,124,125,126,127,18,31,18,19,18,20,7,21,8,9,10,22,11,12,13,5,14,23,15,20,7,21,8,9,10,22,11,12,13,5,14,23,15,20,7,21,8,9,10,22,11,12,13,5,14,23,15,31,7,128,8,9,10,19,11,12,13,5,5,14,19,15,6,1,1,1,2,3,1,1,1,2,3,1,1,1,2,3,1,1,1,2,3,6,1,1,1,2,3,1,1,1,2,3,6,1,1,1,2,3,1,1,1,2,3,6,1,1,1,2,3,1,1,1,2,3,1,1,1,2,3,1,1,1,2,3,6,1,1,1,2,3,1,1,1,2,3,1,1,1,2,3,1,1,1,2,3]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[3],0,[0],[11],[129]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{},{},{},{}],[[[{},"mainColor",8,[4,4294951162]],{},{},{}],11,0,0,0]]],0,0,[0],[1],[0]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"packable":true}],[3],0,[0],[11],[130]],[[[15,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{},{}],[{},{},{},{}],[[[{},"mainColor",8,[4,4278190335]],{},{},{}],11,0,0,0]]],0,0,[0],[1],[0]],[[[4,".bin",639874131,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22080,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22080,"count":460,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0677531510591507,5.827900418113249e-14,0.026122797280550003],"maxPosition",8,[1,-0.06571154296398163,0.004381017293781042,0.02816440537571907]]],-1],0,0,[],[],[]],[[[0,"FrontColor",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6000000238418579,0.6000000238418579,0.4000000059604645]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",1011463886,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8448,"length":1320,"count":330,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":8448,"count":176,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.05057765170931816,0.0009600872872397304,-0.11178639531135559],"maxPosition",8,[1,0.05189765244722366,0.007369999773800373,-0.11046639829874039]]],-1],0,0,[],[],[]],[[[0,"_72",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6117647290229797,0.6235294342041016,0.5803921818733215]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",2448879586,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.10721606761217117,0.011205271817743778,0.07079929858446121],"maxPosition",8,[1,-0.10515493154525757,0.011792033910751343,0.0762372612953186]]],-1],0,0,[],[],[]],[[[4,".bin",1811587937,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":768,"length":96,"count":24,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":768,"count":16,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.06379765272140503,0.02113431878387928,-0.11364923417568207],"maxPosition",8,[1,0.06799765676259995,0.022949066013097763,-0.10838460922241211]]],-1],0,0,[],[],[]],[[[0,"_3",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.9176470637321472,0.9058823585510254,0.48627451062202454]]],11]]],0,0,[0],[1],[0]],[[[0,"_30",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8196078538894653,0.20392157137393951,0.054901961237192154]]],11]]],0,0,[0],[1],[0]],[[[0,"Grass",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"mainTexture",6,0]],11]]],0,0,[0,0],[10,1],[131,0]],[[[0,"_63",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5764706134796143,0.6431372761726379,0.6431372761726379]]],11]]],0,0,[0],[1],[0]],[[[0,"_19",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.7137255072593689,0.8901960849761963,0.8274509906768799]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",286257152,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22080,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22080,"count":460,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.06776680052280426,0.000004128286036575446,-0.060921844094991684],"maxPosition",8,[1,-0.06572519242763519,0.0043851458467543125,-0.05888023599982262]]],-1],0,0,[],[],[]],[[[0,"_14",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.9333333373069763,0.8705882430076599,0.6823529601097107]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",1240172226,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22080,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22080,"count":460,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.07473690062761307,0.000004128286036575446,-0.05396084859967232],"maxPosition",8,[1,-0.072695292532444,0.0043851458467543125,-0.05191924050450325]]],-1],0,0,[],[],[]],[[[0,"_46",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8588235378265381,0.8588235378265381,0.8313725590705872]]],11]]],0,0,[0],[1],[0]],[[[0,"_28",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6784313917160034,0.34117648005485535,0.21568627655506134]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",1897990636,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0176375899463892,0.0026700000744313,-0.018622657284140587],"maxPosition",8,[1,-0.0176375899463892,0.00916806049644947,-0.013276476413011551]]],-1],0,0,[],[],[]],[[[0,"_56",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8588235378265381,0.7843137383460999,0.5058823823928833]]],11]]],0,0,[0],[1],[0]],[[[0,"_101",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,1,0.9921568632125854,0.9333333373069763]]],11]]],0,0,[0],[1],[0]],[[[0,"_60",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5764706134796143,0.6745098233222961,0.6666666865348816]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",2012715959,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22080,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22080,"count":460,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0657615065574646,-0.000004128286036575446,0.026118243113160133],"maxPosition",8,[1,-0.06371989846229553,0.002651033690199256,0.0281598512083292]]],-1],0,0,[],[],[]],[[[0,"_1",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5803921818733215,0.6078431606292725,0.6352941393852234]]],11]]],0,0,[0],[1],[0]],[[[0,"_15",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6235294342041016,0.5960784554481506,0.5411764979362488]]],11]]],0,0,[0],[1],[0]],[[[0,"_6",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,1,0,0]]],11]]],0,0,[0],[1],[0]],[[[0,"_13",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.13333334028720856,0.7098039388656616,0.6784313917160034]]],11]]],0,0,[0],[1],[0]],[[[0,"_71",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5529412031173706,0.364705890417099,0.22745098173618317]]],11]]],0,0,[0],[1],[0]],[[[0,"_81",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.3294117748737335,0.4745098054409027,0.48627451062202454]]],11]]],0,0,[0],[1],[0]],[[[0,"_21",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8274509906768799,0.8196078538894653,0.7764706015586853]]],11]]],0,0,[0],[1],[0]],[[[0,"_25",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.4901960790157318,0.6392157077789307,0.6509804129600525]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",2656072462,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2784,"length":408,"count":102,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":3672,"length":72,"count":18,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":7104,"length":504,"count":126,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":7800,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2784,"count":58,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3192,"length":480,"count":10,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3744,"length":3360,"count":70,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":7608,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.01832321472465992,0.0005200000014156103,-0.019735485315322876],"maxPosition",8,[1,-0.016689660027623177,0.010940000414848328,-0.01216366421431303]]],-1],0,0,[],[],[]],[[[4,".bin",3445485762,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":11520,"length":960,"count":240,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":11520,"count":240,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0035936722997576,0.02859635464847088,-0.11014122515916824],"maxPosition",8,[1,-0.002511022612452507,0.029679004102945328,-0.10911156982183456]]],-1],0,0,[],[],[]],[[[4,".bin",2538371729,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":768,"length":96,"count":24,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":768,"count":16,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.07149765640497208,0.02113431878387928,-0.11364923417568207],"maxPosition",8,[1,0.0756976529955864,0.022949066013097763,-0.10838460922241211]]],-1],0,0,[],[],[]],[[[0,"_32",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.43529412150382996,0.26274511218070984,0.1725490242242813]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",700181513,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":310608,"length":55272,"count":13818,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":381480,"length":2832,"count":708,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[2],"indexView":{"offset":922152,"length":103032,"count":25758,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[3],"indexView":{"offset":1118352,"length":15132,"count":3783,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[4],"indexView":{"offset":1225740,"length":16812,"count":4203,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[5],"indexView":{"offset":1242744,"length":24,"count":6,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[6],"indexView":{"offset":1263984,"length":4392,"count":1098,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[7],"indexView":{"offset":1268760,"length":48,"count":12,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[8],"indexView":{"offset":1280328,"length":1440,"count":360,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[9],"indexView":{"offset":1282920,"length":192,"count":48,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[10],"indexView":{"offset":1296312,"length":2508,"count":627,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[11],"indexView":{"offset":1357668,"length":9864,"count":2466,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[12],"indexView":{"offset":1439964,"length":16716,"count":4179,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[13],"indexView":{"offset":1461480,"length":1152,"count":288,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[14],"indexView":{"offset":1482216,"length":3288,"count":822,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[15],"indexView":{"offset":1492032,"length":912,"count":228,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[16],"indexView":{"offset":1503072,"length":1644,"count":411,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[17],"indexView":{"offset":1508508,"length":780,"count":195,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[18],"indexView":{"offset":1518312,"length":1704,"count":426,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[19],"indexView":{"offset":1536288,"length":2724,"count":681,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[20],"indexView":{"offset":1706484,"length":29616,"count":7404,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[21],"indexView":{"offset":1763220,"length":5544,"count":1386,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[22],"indexView":{"offset":1785276,"length":2088,"count":522,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[23],"indexView":{"offset":2015412,"length":27684,"count":6921,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[24],"indexView":{"offset":2045592,"length":360,"count":90,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[25],"indexView":{"offset":2046720,"length":168,"count":42,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[26],"indexView":{"offset":2060136,"length":2160,"count":540,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[27],"indexView":{"offset":2063160,"length":192,"count":48,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[28],"indexView":{"offset":2066856,"length":564,"count":141,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[29],"indexView":{"offset":2081580,"length":3780,"count":945,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[30],"indexView":{"offset":2133072,"length":9144,"count":2286,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[31],"indexView":{"offset":2172792,"length":6372,"count":1593,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[32],"indexView":{"offset":2184444,"length":1056,"count":264,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[33],"indexView":{"offset":2187324,"length":624,"count":156,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[34],"indexView":{"offset":2198892,"length":1896,"count":474,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[35],"indexView":{"offset":2208324,"length":1500,"count":375,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[36],"indexView":{"offset":2210976,"length":144,"count":36,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[37],"indexView":{"offset":2233728,"length":4284,"count":1071,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[38],"indexView":{"offset":2239164,"length":192,"count":48,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[39],"indexView":{"offset":2240124,"length":120,"count":30,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[40],"indexView":{"offset":2240868,"length":108,"count":27,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[41],"indexView":{"offset":2247120,"length":912,"count":228,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[42],"indexView":{"offset":2252112,"length":636,"count":159,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[43],"indexView":{"offset":2269020,"length":2100,"count":525,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[44],"indexView":{"offset":2271504,"length":48,"count":12,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[45],"indexView":{"offset":2317968,"length":9060,"count":2265,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[46],"indexView":{"offset":2330676,"length":720,"count":180,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[47],"indexView":{"offset":2331588,"length":24,"count":6,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[48],"indexView":{"offset":2351724,"length":4296,"count":1074,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[49],"indexView":{"offset":2368740,"length":1740,"count":435,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[50],"indexView":{"offset":2381712,"length":1848,"count":462,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[51],"indexView":{"offset":2428968,"length":7620,"count":1905,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[52],"indexView":{"offset":2489340,"length":7452,"count":1863,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[53],"indexView":{"offset":2529528,"length":4128,"count":1032,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[54],"indexView":{"offset":2534040,"length":48,"count":12,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[55],"indexView":{"offset":2537832,"length":600,"count":150,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[56],"indexView":{"offset":2590944,"length":9732,"count":2433,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[57],"indexView":{"offset":2607732,"length":1644,"count":411,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[58],"indexView":{"offset":2610672,"length":324,"count":81,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[59],"indexView":{"offset":2624100,"length":1980,"count":495,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[60],"indexView":{"offset":2628864,"length":576,"count":144,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[61],"indexView":{"offset":2844912,"length":39936,"count":9984,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[62],"indexView":{"offset":2921568,"length":7236,"count":1809,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[63],"indexView":{"offset":2946708,"length":3180,"count":795,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[64],"indexView":{"offset":2959488,"length":1584,"count":396,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[65],"indexView":{"offset":2989728,"length":4548,"count":1137,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[66],"indexView":{"offset":3003012,"length":1368,"count":342,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[67],"indexView":{"offset":3005772,"length":204,"count":51,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[68],"indexView":{"offset":3008088,"length":336,"count":84,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[69],"indexView":{"offset":3010728,"length":288,"count":72,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":310608,"count":6471,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":365880,"length":15600,"count":325,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":384312,"length":537840,"count":11205,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1025184,"length":93168,"count":1941,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1133484,"length":92256,"count":1922,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1242552,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1242768,"length":21216,"count":442,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1268376,"length":384,"count":8,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1268808,"length":11520,"count":240,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1281768,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1283112,"length":13200,"count":275,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1298820,"length":58848,"count":1226,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1367532,"length":72432,"count":1509,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1456680,"length":4800,"count":100,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1462632,"length":19584,"count":408,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1485504,"length":6528,"count":136,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1492944,"length":10128,"count":211,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1504716,"length":3792,"count":79,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1509288,"length":9024,"count":188,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1520016,"length":16272,"count":339,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1539012,"length":167472,"count":3489,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1736100,"length":27120,"count":565,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1768764,"length":16512,"count":344,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":1787364,"length":228048,"count":4751,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2043096,"length":2496,"count":52,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2045952,"length":768,"count":16,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2046888,"length":13248,"count":276,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2062296,"length":864,"count":18,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2063352,"length":3504,"count":73,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2067420,"length":14160,"count":295,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2085360,"length":47712,"count":994,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2142216,"length":30576,"count":637,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2179164,"length":5280,"count":110,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2185500,"length":1824,"count":38,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2187948,"length":10944,"count":228,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2200788,"length":7536,"count":157,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2209824,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2211120,"length":22608,"count":471,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2238012,"length":1152,"count":24,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2239356,"length":768,"count":16,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2240244,"length":624,"count":13,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2240976,"length":6144,"count":128,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2248032,"length":4080,"count":85,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2252748,"length":16272,"count":339,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2271120,"length":384,"count":8,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2271552,"length":46416,"count":967,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2327028,"length":3648,"count":76,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2331396,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2331612,"length":20112,"count":419,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2356020,"length":12720,"count":265,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2370480,"length":11232,"count":234,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2383560,"length":45408,"count":946,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2436588,"length":52752,"count":1099,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2496792,"length":32736,"count":682,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2533656,"length":384,"count":8,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2534088,"length":3744,"count":78,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2538432,"length":52512,"count":1094,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2600676,"length":7056,"count":147,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2609376,"length":1296,"count":27,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2610996,"length":13104,"count":273,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2626080,"length":2784,"count":58,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2629440,"length":215472,"count":4489,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2884848,"length":36720,"count":765,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2928804,"length":17904,"count":373,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2949888,"length":9600,"count":200,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2961072,"length":28656,"count":597,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":2994276,"length":8736,"count":182,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3004380,"length":1392,"count":29,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3005976,"length":2112,"count":44,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":3008424,"length":2304,"count":48,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.2022482454776764,-0.0006000000284984708,-0.13428640365600586],"maxPosition",8,[1,0.22241425514221191,0.04896000027656555,0.1474287062883377]]],-1],0,0,[],[],[]],[[[0,"_87",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8392156958580017,0.886274516582489,0.6509804129600525]]],11]]],0,0,[0],[1],[0]],[[[0,"_40",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.7607843279838562,0.4156862795352936,0.20000000298023224]]],11]]],0,0,[0],[1],[0]],[[[0,"_53",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5137255191802979,0.4901960790157318,0.4901960790157318]]],11]]],0,0,[0],[1],[0]],[[[0,"Ivory",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,1,1,0.9411764740943909]]],11]]],0,0,[0],[1],[0]],[[[0,"_80",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.9450980424880981,0.7921568751335144,0.7686274647712708]]],11]]],0,0,[0],[1],[0]],[[[0,"_134",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6549019813537598,0.3490196168422699,0.32156863808631897]]],11]]],0,0,[0],[1],[0]],[[[0,"_83",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6509804129600525,0.658823549747467,0.5372549295425415]]],11]]],0,0,[0],[1],[0]],[[[0,"_61",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.45490196347236633,0.33725491166114807,0.21176470816135406]]],11]]],0,0,[0],[1],[0]],[[[0,"_20",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6274510025978088,0.6078431606292725,0.6509804129600525]]],11]]],0,0,[0],[1],[0]],[[[0,"_115",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.4901960790157318,0.41960784792900085,0.42352941632270813]]],11]]],0,0,[0],[1],[0]],[[[0,"_2",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6823529601097107,0.40392157435417175,0.1921568661928177]]],11]]],0,0,[0],[1],[0]],[[[0,"_39",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.32156863808631897,0.1882352977991104,0.18039216101169586]]],11]]],0,0,[0],[1],[0]],[[[0,"_91",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.9215686321258545,0.9411764740943909,0.7490196228027344]]],11]]],0,0,[0],[1],[0]],[[[0,"_9",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.772549033164978,0.545098066329956,0.529411792755127]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",877702964,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22080,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22080,"count":460,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.07473410665988922,2.5320366056668167e-14,0.017145095393061638],"maxPosition",8,[1,-0.07269249856472015,0.0026551620103418827,0.019186703488230705]]],-1],0,0,[],[],[]],[[[4,".bin",3746972950,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":11520,"length":960,"count":240,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":11520,"count":240,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.01770632714033127,0.02859635464847088,-0.11014122515916824],"maxPosition",8,[1,0.018788976594805717,0.029679004102945328,-0.10911156982183456]]],-1],0,0,[],[],[]],[[[0,"_34",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.24313725531101227,0.14901961386203766,0.03529411926865578]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",3629062475,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":768,"length":96,"count":24,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":768,"count":16,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.05609765276312828,0.02113431878387928,-0.11364923417568207],"maxPosition",8,[1,0.0602976530790329,0.022949066013097763,-0.10838460922241211]]],-1],0,0,[],[],[]],[[[0,"_33",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6745098233222961,0.6666666865348816,0.6352941393852234]]],11]]],0,0,[0],[1],[0]],[[[0,"LightBlue2",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6784313917160034,0.8470588326454163,0.9019607901573181]]],11]]],0,0,[0],[1],[0]],[[[0,"_24",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6941176652908325,0.9058823585510254,0.9215686321258545]]],11]]],0,0,[0],[1],[0]],[[[0,"_36",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.20000000298023224,0.20000000298023224,0.20000000298023224]]],11]]],0,0,[0],[1],[0]],[[[0,"_17",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5098039507865906,0.5215686559677124,0.49803921580314636]]],11]]],0,0,[0],[1],[0]],[[[0,"_38",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.3176470696926117,0.37254902720451355,0.34117648005485535]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",2883094498,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3744,"length":888,"count":222,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":4824,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3744,"count":78,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":4632,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.05031394585967064,0.010376650840044022,-0.1104263961315155],"maxPosition",8,[1,0.051838744431734085,0.011901448480784893,-0.11030639708042145]]],-1],0,0,[],[],[]],[[[0,"_86",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6549019813537598,0.07450980693101883,0.0470588244497776]]],11]]],0,0,[0],[1],[0]],[[[27,"White",[{"metallic":0.4000000059604645,"roughness":0.30151134729385376}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[1],[0]],[[[0,"_62",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.7960784435272217,0.7921568751335144,0.8117647171020508]]],11]]],0,0,[0],[1],[0]],[[[0,"_44",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.25882354378700256,0.5137255191802979,0.2823529541492462]]],11]]],0,0,[0],[1],[0]],[[[0,"_18",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8784313797950745,0.8823529481887817,0.3960784375667572]]],11]]],0,0,[0],[1],[0]],[[[0,"_79",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8313725590705872,0.42352941632270813,0.42352941632270813]]],11]]],0,0,[0],[1],[0]],[[[0,"_16",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5803921818733215,0.11372549086809158,0.09019608050584793]]],11]]],0,0,[0],[1],[0]],[[[0,"_57",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.16470588743686676,0.48627451062202454,0.33725491166114807]]],11]]],0,0,[0],[1],[0]],[[[0,"_70",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5098039507865906,0.5176470875740051,0.48235294222831726]]],11]]],0,0,[0],[1],[0]],[[[0,"_26",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.7372549176216125,0.46666666865348816,0.2980392277240753]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",2335756962,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":11520,"length":960,"count":240,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":11520,"count":240,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.010632822290062904,0.02993614412844181,-0.1101677194237709],"maxPosition",8,[1,0.011662483215332031,0.03101879358291626,-0.1090850755572319]]],-1],0,0,[],[],[]],[[[27,"_10",[{"metallic":0.4000000059604645,"roughness":0.30151134729385376}],[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}]]],0,0,[0],[1],[0]],[[[0,"_59",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.772549033164978,0.6509804129600525,0.5764706134796143]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",3412220607,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":11520,"length":960,"count":240,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":11520,"count":240,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.003532822011038661,0.02993614412844181,-0.1101677194237709],"maxPosition",8,[1,0.0045624831691384315,0.03101879358291626,-0.1090850755572319]]],-1],0,0,[],[],[]],[[[0,"_76",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8117647171020508,1,0.9803921580314636]]],11]]],0,0,[0],[1],[0]],[[[0,"_37",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.16470588743686676,0.16470588743686676,0.15294118225574493]]],11]]],0,0,[0],[1],[0]],[[[0,"_73",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.43529412150382996,0.5490196347236633,0.47843137383461]]],11]]],0,0,[0],[1],[0]],[[[0,"_84",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,1,0.9607843160629272,0.9529411792755127]]],11]]],0,0,[0],[1],[0]],[[[0,"_51",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8313725590705872,0.7607843279838562,0.6352941393852234]]],11]]],0,0,[0],[1],[0]],[[[0,"_4",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0,0,0]]],11]]],0,0,[0],[1],[0]],[[[0,"_7",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.3490196168422699,0.8078431487083435,0.5764706134796143]]],11]]],0,0,[0],[1],[0]],[[[0,"_42",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.40784314274787903,0.8078431487083435,0.40392157435417175]]],11]]],0,0,[0],[1],[0]],[[[0,"_29",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,1,0.9882352948188782,0.9411764740943909]]],11]]],0,0,[0],[1],[0]],[[[0,"_55",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.8980392217636108,0,0]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",378058353,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":768,"length":96,"count":24,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":1056,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":768,"count":16,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":864,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.17043565213680267,0.0003665999975055456,-0.11538384109735489],"maxPosition",8,[1,0.1705484539270401,0.0028200000524520874,-0.11346624046564102]]],-1],0,0,[],[],[]],[[[0,"_117",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.45490196347236633,0.5490196347236633,0.6745098233222961]]],11]]],0,0,[0],[1],[0]],[[[0,"_43",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.5137255191802979,0.5137255191802979,0.5137255191802979]]],11]]],0,0,[0],[1],[0]],[[[0,"_48",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.20000000298023224,0.5137255191802979,0.21176470816135406]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",1278713831,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22080,"length":2640,"count":660,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22080,"count":460,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0747295543551445,0.000004128286036575446,0.019136741757392883],"maxPosition",8,[1,-0.07268794625997543,0.0043851458467543125,0.02117834985256195]]],-1],0,0,[],[],[]],[[[0,"_77",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.3294117748737335,0.5176470875740051,0.2705882489681244]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",415591391,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":288,"length":48,"count":12,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":288,"count":6,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.048101916909217834,0.007412000093609095,0.015301601961255074],"maxPosition",8,[1,0.048101916909217834,0.01570799946784973,0.019653601571917534]]],-1],0,0,[],[],[]],[[[4,".bin",2116374242,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":216,"count":54,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.030421916395425797,0.0027199999894946814,-0.0017663979670032859],"maxPosition",8,[1,0.033821914345026016,0.003263999940827489,0.0016336020780727267]]],-1],0,0,[],[],[]],[[[0,"_92",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6313725709915161,0.3137255012989044,0.27843138575553894]]],11]]],0,0,[0],[1],[0]],[[[0,"_75",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6470588445663452,0.4431372582912445,0.30588236451148987]]],11]]],0,0,[0],[1],[0]],[[[4,".bin",2816553818,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":624,"length":132,"count":33,"stride":4}},{"primitiveMode":7,"vertexBundelIndices":[1],"indexView":{"offset":6516,"length":840,"count":210,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":624,"count":13,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]},{"view":{"offset":756,"length":5760,"count":120,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0130679402500391,0.0005200000014156103,-0.016129473224282265],"maxPosition",8,[1,-0.012707940302789211,0.029820000752806664,-0.0157694723457098]]],-1],0,0,[],[],[]],[[[0,"_85",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"albedoScale",8,[1,0.6000000238418579,0.6000000238418579,0.6000000238418579]]],11]]],0,0,[0],[1],[0]],[[[30,[{}]]],0,0,[0],[1],[0]]]]
